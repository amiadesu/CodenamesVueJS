// @ts-check
const mongoose = require("mongoose");
const userSchema = require("../MongoDBSchemas/User");

const { config } = require("../../../utils/config");

const { createClient } = require("redis");
const redisAtomic = require("./Redis/redisAtomic");

const {
    userExample,
    validKeys,
    bannedRooms,
    deleteAfterMNumber,
    updateAfterMNumber,
    deleteAfterS,
    updateAfterS,
    expireAfterS,
    deleteAfterMs,
    updateAfterMs,
    expireAfterMs,
    messagesLimitNumber,
    cluesLimitNumber,
    messagesLimit,
    cluesLimit,
    LOCK_TTL
} = require("../utils/constants");

class GlobalDB {

    #redisClient;
    #mongoDBClient;
    #User;
    #redisAvailable = false;
    
    constructor() {
        this.#redisClient = createClient(config.redis.clientOptions);
        this.#redisClient.on('error', err => console.log('Redis Global Client Error', err));
    }

    async initialize() {
        try {
            this.#mongoDBClient = await mongoose.createConnection(`${config.mognoDB.baseUrl}/global`).asPromise();
            console.log('Connected to Global MongoDB');
            this.#User = await this.#mongoDBClient.model("User", userSchema);
        } catch(error) {
            console.error('Could not connect to Global MongoDB:', error);
            throw error;
        }
        try {
            await this.#redisClient.connect();
            await redisAtomic.init(this.#redisClient);
            
            console.log('Connected to Global Redis');

            this.#redisAvailable = true;
            this.#setupAutomaticRoomPropagation();
    
        } catch (error) {
            console.error('Could not connect to Global Redis:', error);
            this.#redisAvailable = false;
        }
    }

    #validKey(key) {
        return (validKeys.includes(key));
    }

    async #fetchDataFromMongoDB(userId, key) {
        try {
            const result = await mongoDBAtomic.getRoomData(userId, key);
            console.log(result);

            const value = result.success ? result.value : null;

            if (this.#redisAvailable && value) {
                await redisAtomic.set(userId, key, value, expireAfterS);
            }

            return { success: true, value: value };
        } catch (error) {
            console.log("Error while fetching data from MongoDB:", error);
            return { success: false, error: error.message };
        }
        
    }

    #getRedisKey(userId, key) {
        if (!userId) throw new Error('User ID is required');
        return key ? `user:${userId}:${key.replace(/\./g, ':')}` : `user:${userId}`;
    }

    async #createRedisEntry(userId, key, skipLock = false) {
        if (!this.#redisAvailable) return;

        const redisKey = this.#getRedisKey(userId, key);
        const hydrate = async () => {
            const exists = await this.#redisClient.exists(redisKey);
            if (!exists) {
                const result = await this.#fetchDataFromMongoDB(userId, key);
                if (!result.success) {
                    console.error("Failed to fetch from Mongo during Redis entry creation:", result.error);
                }
            }
        };

        if (skipLock) {
            return await hydrate();
        }
    
        const lockKey = `lock:${redisKey}`;
        const lockValue = `${process.pid}-${Date.now()}-${Math.random()}`;
        
    
        const lockSet = await this.#redisClient.set(lockKey, lockValue, { NX: true, PX: LOCK_TTL });
    
        if (!lockSet) return;
    
        try {
            const exists = await this.#redisClient.exists(redisKey);
            if (!exists) {
                const result = await this.#fetchDataFromMongoDB(userId, key);
                if (!result.success) {
                    console.error("Failed to fetch from Mongo during Redis entry creation:", result.error);
                }
            }
        } finally {
            const currentValue = await this.#redisClient.get(lockKey);
            if (currentValue === lockValue) {
                await this.#redisClient.del(lockKey);
            }
        }
    }

    async #withRedisLock(redisKey, fn) {
        const lockKey = `lock:${redisKey}`;
        const lockValue = `${process.pid}-${Date.now()}-${Math.random()}`;
        console.log(lockKey, lockValue);
        const acquired = await this.#redisClient.set(lockKey, lockValue, { NX: true, PX: LOCK_TTL });
        console.log(acquired);
        if (!acquired) return { success: false, error: "Could not acquire lock" };
    
        try {
            return await fn();
        } finally {
            const currentValue = await this.#redisClient.get(lockKey);
            if (currentValue === lockValue) {
                await this.#redisClient.del(lockKey);
            }
        }
    }

    async #withMultiRedisLocks(keys, fn) {
        const sorted = [...keys].sort();
        const acquire = async (index) => {
            if (index === sorted.length) return await fn();
            return await this.#withRedisLock(sorted[index], () => acquire(index + 1));
        };
        return await acquire(0);
    }

    #setupAutomaticRoomPropagation() {
        if (!this.#redisAvailable) return;

        setInterval(async () => {
            try {
                const updateKeys = [];
                let cursor = "0";
                do {
                    const reply = await this.#redisClient.scan(cursor, { MATCH: 'user:*', COUNT: 100 });
                    cursor = reply.cursor;
                    updateKeys.push(...reply.keys);
                } while (cursor !== "0");

                const userDataMap = new Map();

                for (const key of updateKeys) {
                    const [, userId, field] = key.split(':');
                    const value = await this.#redisClient.get(key);
                    if (value) {
                        let roomData = userDataMap.get(userId);
                        if (!roomData) {
                            roomData = {};
                            userDataMap.set(userId, roomData);
                        }
                        roomData[field] = JSON.parse(value);
                    }
                }

                for (const [userId, data] of userDataMap) {
                    await mongoDBAtomic.setRoomData(userId, null, data);
                }
            } catch (err) {
                console.error('Sync worker error:', err);
            }
        }, +updateAfterMs);
    }

    async createUserEntry(userId) {
        try {
            const userObj = await this.#User.findOne({ _id: userId }).exec();
            if (!userObj) {
                const user = new this.#User();
                await user.save();
                console.log(user._id.toString());
                return {
                    newUser: true,
                    realUserID: user._id.toString()
                };
            } else {
                console.log(userObj._id.toString());
                return {
                    newUser: false,
                    realUserID: userObj._id.toString()
                };
            }
        }
        catch (error) {
            // Questionable code
            const user = new this.#User();
            await user.save();
            console.log(user._id.toString());
            return {
                newUser: true,
                realUserID: user._id.toString()
            };
        }
    }
    
    async getUserData(userId, key) {
        if (userId === "") {
            return null;
        }
        if (!this.#validKey(key)) {
            console.log("Invalid key given: ", key);
            return null;
        }
        const result = await this.#User.findOne({
            _id : userId
        }).select(`${key} -_id`).exec();
        return result[key];
    }
    
    async getFullUserData(userId) {
        const result = await this.#User.findOne({
            _id: userId
        }).exec();
        if (result) {
            return result;
        } else {
            return null;
        }
    }
    
    async setUserData(userId, key, value) {
        if (userId === "") {
            return { success: false, error: "User ID is empty." };
        }
        if (!this.#validKey(key)) {
            const errorMessage = `Invalid key given: ${key}.`;
            return { success: false, error: errorMessage };
        }
        const updateQuery = { $set: { [key]: value } };
        await this.#User.updateOne(
            { _id : userId },
            updateQuery
        );
        return { success: true };
    }
    
    async updateUserData(userId, newData) {
        if (userId === "") {
            return null;
        }
        await this.#User.updateOne(
            { _id : userId },
            { $set: { ...newData } }
        );
    }
    
    async checkIfUserExists(key, value) {
        try {
            if (!this.#validKey(key)) {
                throw Error(`Invalid key: ${key}.`)
            }
    
            const existingUser = await this.#User.findOne({
                [key] : value
            });
            
            return existingUser !== null;
        } 
        catch (error) {
            console.log("Error:", error);
            return true;
        }
    }
}



module.exports = {
    connectGlobalDB,
    createUserEntry,
    getUserData,
    getFullUserData,
    setUserData,
    updateUserData,
    checkIfUserExists
};