const path = require('path');
const z = require("zod/v4");
const { Mutex } = require('async-mutex');
const mutex = new Mutex();

const {
    validTeamColorZodSchema,
    validPlayerColorZodSchema,
    validWordColorZodSchema,
    packIdZodSchema,
    gameRulesZodSchemaNonStrict,
    gameRulesZodSchemaStrict,
    clueTextZodSchema,
    clueZodSchema,
    playerIdZomSchema,
    playerZodSchema,
    wordZodSchema,
    chatMessageZodSchema
} = require("../../ZodSchemas/Codenames/codenamesZodSchemas");
const { 
    usernameZodSchema,
    userColorZodSchema,
    userZodSchema,
    roomIdZodSchema
} = require("../../ZodSchemas/Global/globalZodSchemas");
const {
    connectCodenamesDB,
    setupAutomaticCodenamesRoomDeletion,
    getFreeRoom,
    createCodenamesRoom,
    deleteCodenamesRoom,
    getCodenamesRoomData,
    setCodenamesRoomData,
    addCodenamesChatMessageToRoomData,
    getCodenamesWordPack,
    getCodenamesWordPackNoWords,
    getCodenamesWordPackWordsOnly,
    getAllCodenamesWordPacks,
    setCodenamesWordPack
} = require("./db/codenamesDB");
const {
    isObject,
    makeID,
    makeColor,
    randChoice,
    shuffle
} = require("../../utils/extra");
const {
    setupWordPackWatcher
} = require("./db/wordPacksDB");

const DIContainer = require("./logic/container");
const {
    gameboard,
    gameManager,
    gameSetup,
    permissionsValidation,
    words
} = require("./logic/container");


const {
    validateUser,
    checkPermissions
} = require("./logic/permissionsValidation");
const {
    getWordsFromPack,
    getWordsForRoom,
    getNewWords,
    getGameboard
} = require("./logic/gameboard");
const {
    toggleWord,
    toggleWordNoSave,
    clearWord,
    clearWordNoSave,
    revealWord,
    wordAutoselect,
    clearAllSelections
} = require("./logic/words");
const {
    updateTeamOrder,
    updateUser,
    passTurn,
    processWin,
    clearTimer,
    updateGameTimer,
    removeAllPlayers,
    removePlayer,
    randomizePlayers,
    transferHost
} = require("./logic/gameManager");
const {
    clearRoles,
    setupGamemode,
    startNewGame
} = require("./logic/gameSetup");

const codenamesPacksFolderPath = path.join(__dirname, '..', '..', 'WordPacks', 'Codenames');

const {
    processUser,
    updateGlobalUser,
    createNewGameID
} = require("../Global/utils/userRegistration");

const {
    Permissions,
    validEventsWithoutAuthorization
} = require("./utils/constants");

const RoomContext = require("./db/roomContext");

let io = null;

function setupCodenames(codenamesIo) {
    io = codenamesIo;
    connectCodenamesDB().then(() => {
        setupWordPackWatcher(codenamesPacksFolderPath);
        createIOListener();
    });
}

async function safeRoomDataAccess(room, callback) {
    const release = await mutex.acquire();
    try {
        await callback(room);
    } finally {
        release();
    }
}

const clearRooms = setupAutomaticCodenamesRoomDeletion();

function totalCards(gameRules) {
    let extraSum = 0;
    for (let i = 0; i < gameRules.teamAmount - 1; i++) {
        extraSum += gameRules.extraCards[i];
    }
    const totalCardAmount = gameRules.teamAmount * gameRules.baseCards + 
                            extraSum + gameRules.blackCards;
    return totalCardAmount;
}

let eventCount = 0;

function createIOListener() {
    io.use(async (socket, next) => {
        const userID = socket.handshake.auth.userID;
    
        socket.userData = await processUser(userID, socket.id, io.sockets);
        const result = playerIdZomSchema.safeParse(socket.userData.gameIDs.codenames);
        if (!result.success) {
            const newGameIDResult = await createNewGameID(userID, "codenames");
            if (!newGameIDResult.success) {
                console.log(newGameIDResult.error);
                return;
            }
            const newUserCodenamesID = newGameIDResult.value;
            socket.userData.gameIDs.codenames = newUserCodenamesID;
        }
    
        next();
    });
    io.on('connection', async (socket) => {
        console.log('User connected:', socket.id);

        let userId = socket.userData.userID;
        let userCodenamesId = socket.userData.gameIDs.codenames;
        console.log('User id:', userId);
        console.log("User Codenames ID:", userCodenamesId);
        let user = null;
        let roomId = "default";
        let settedUp = false;
        let countdownInterval = null;
        let timerInterval = null;
        let status = {
            setup_event : {
                active: false
            }
        };

        socket.use(async ([event, data], next) => {
            console.log(event, data);
            eventCount++;
            console.log(eventCount);
            if (!validEventsWithoutAuthorization.includes(event)) {
                if (roomId === "default") {
                    return next(new Error('Unauthorized event'));
                }
                const room = new RoomContext(roomId);
                const userIsAuthorized = await validateUser(room, userCodenamesId);
                if (!userIsAuthorized) {
                    return next(new Error('Unauthorized event'));
                }
            }
            else {
                if (!(typeof data === 'string' || data instanceof String || !data) || data === "default") {
                    return next(new Error('Unauthorized event'));
                }
            }
            next();
        });
        
        socket.on("error", (err) => {
            if (err && err.message === 'Unauthorized event') {
                console.log("Unauthorized access blocked.");
                socket.disconnect(true);
            }
        });

        socket.emit("update_local_storage_data", {
            userID: socket.userData.userID
        });
    


        socket.on("create_room", async () => {
            const result = await getFreeRoom();
            if (!result.success) {
                console.log(result.error);
                socket.emit("error_message", { error: "Couldn't find any free room. Please try again later." });
            }
            socket.emit("get_free_room_code", result.value);
        });
        
        socket.on("process_room", (newRoomId) => {
            let result = roomIdZodSchema.safeParse(newRoomId);
            if (!result.success) {
                console.log("Zod error:", result.error);
                socket.emit("error_message", { error: "The room code is not valid. The room code must contain from 1 to 16 characters and consist only of Latin letters and numbers." });
                return;
            }
            newRoomId = result.data;

            roomId = newRoomId;
            socket.join(roomId);
        });
    
        socket.on("setup_client", async (newRoomId) => {
            let result = roomIdZodSchema.safeParse(newRoomId);
            if (!result.success) {
                console.log("Zod error:", result.error);
                socket.emit("error_message", { error: "The room code is not valid. The room code must contain from 1 to 16 characters and consist only of Latin letters and numbers." });
                return;
            }
            newRoomId = result.data;

            if (status.setup_event.active) {
                socket.emit("error_message", { error: "You are still being set up." });
                return;
            }

            status.setup_event.active = true;

            roomId = newRoomId;
            socket.join(roomId);

            const room = new RoomContext(roomId);
    
            const shouldGetNewWords = await createCodenamesRoom(room.roomId);

            if (!shouldGetNewWords.success) {
                return;
            }

            if (shouldGetNewWords.value) {
                await getNewWords(room);
            }
            let users = await room.getUsers();
            let teams = await room.getTeams();
            let gameRules = await room.getGameRules();
            let gameProcess = await room.getGameProcess();
    
            const objIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            if (objIndex !== -1) {
                users[objIndex].online = true;
                user = users[objIndex];
                await updateUser(room, users[objIndex]);
                users = await room.getUsers();
                teams = await room.getTeams();
            }
            else {
                user = {
                    name: socket.userData.name,
                    color: socket.userData.color,
                    id: userCodenamesId,
                    roomId: roomId,
                    state: {
                        teamColor: "spectator",
                        master: false,
                        selecting: ""
                    },
                    online: true,
                    host: false
                };
    
                if (users.length === 0) {
                    user.host = true;
                }
    
                users.push(user);
            }
            
            room.setUsers(users);

            await room.save();
    
            settedUp = true;

            let gameWinStatus = await room.getGameWinStatus();
            let chatMessages = await room.getChatMessages();
            
            socket.to(roomId).emit("update_users", teams, users);
            socket.emit("update_client_setup", teams, users, user, gameRules, gameProcess, gameWinStatus, chatMessages);
            socket.emit("set_initialized");
            socket.emit("request_new_gameboard");

            await room.save();

            status.setup_event.active = false;
        });
    
        socket.on("edit_user", async (newUser) => {
            let result = playerZodSchema.safeParse(newUser);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            newUser = result.data;

            const room = new RoomContext(roomId);

            let users = await room.getUsers();
    
            const objIndex = users.findIndex((obj) => obj.id === newUser.id);
            users[objIndex].name = newUser.name;
            await updateUser(room, users[objIndex]);
    
            users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });

        socket.on("edit_name", async (newName) => {
            let result = usernameZodSchema.safeParse(newName);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            newName = result.data;

            const room = new RoomContext(roomId);

            let users = await room.getUsers();
    
            const objIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            users[objIndex].name = newName;
            await updateUser(room, users[objIndex]);
            await updateGlobalUser(userId, { name: newName });
    
            users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });

        socket.on("change_color", async () => {
            const room = new RoomContext(roomId);

            let users = await room.getUsers();
            const newColor = makeColor();
    
            const objIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            users[objIndex].color = newColor;
            await updateUser(room, users[objIndex]);
            await updateGlobalUser(userId, { color: newColor });
    
            users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });
    
        socket.on("state_changed", async (previousColor, newUser) => {
            let result = validPlayerColorZodSchema.safeParse(previousColor);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            previousColor = result.data;
            result = playerZodSchema.safeParse(newUser);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            newUser = result.data;

            const room = new RoomContext(roomId);
            
            let users = await room.getUsers();
            let teams = await room.getTeams();

            const objIndex = users.findIndex((obj) => obj.id === newUser.id);
            if (objIndex === -1) {
                return;
            }
            if (newUser.host && !users[objIndex].host) {
                console.log("Privilege escalation attempt was blocked.");
                return;
            }

            if (previousColor !== "spectator") {
                const objIndex = teams[previousColor].team.findIndex((player) => player.id === newUser.id);
                if (teams[previousColor].master?.id === newUser.id) {
                    teams[previousColor].master = null;
                } else if (objIndex !== -1) {
                    teams[previousColor].team.splice(objIndex, 1);
                }
            }
            if (newUser.state.teamColor !== "spectator") {
                if (newUser.state.master) {
                    teams[newUser.state.teamColor].master = newUser;
                } else {
                    teams[newUser.state.teamColor].team.push(newUser);
                }
            }
            let updateEveryone = false;
            if (newUser.state.selecting !== "") {
                updateEveryone = true;
                await toggleWord(room, newUser.state.selecting, objIndex, countdownInterval);
                users = await room.getUsers();
            }
            users[objIndex].state = newUser.state;
            users[objIndex].state.selecting = "";

            room.setUsers(users);
            room.setTeams(teams);

            await room.save();
    
            io.to(roomId).emit("update_users", teams, users);
            if (updateEveryone) {
                io.to(roomId).emit("request_new_gameboard");
            } else {
                const words = await getGameboard(room, userCodenamesId);
                socket.emit("send_new_gameboard", words);
            }

            await room.save();
        });
    
        socket.on("notify_server_about_change", () => {
            socket.emit("notify_client_about_change");
        });
    
        socket.on("get_gameboard", async () => {
            const room = new RoomContext(roomId);

            const words = await getGameboard(room, userCodenamesId);

            const gameRules = await room.getGameRules();
    
            socket.emit("send_new_gameboard", words);
            socket.emit("update_game_rules", gameRules);

            await room.save();
        });
    
        socket.on("refresh_gameboard", async () => {
            const room = new RoomContext(roomId);

            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }

            let gameRules = await room.getGameRules();
    
            const newCardsAmount = totalCards(gameRules);
            if (newCardsAmount > gameRules.maxCards) {
                socket.emit("error_message", "cardAmountError");
                return;
            } 
            await getNewWords(room);
    
            io.to(roomId).emit("request_new_gameboard");

            await room.save();
        });
    
        socket.on("randomize_team_order", async () => {
            const room = new RoomContext(roomId);

            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }
    
            await updateTeamOrder(room);
            
            let gameRules = await room.getGameRules();
            
            io.to(roomId).emit("update_game_rules", gameRules);

            await room.save();
        });
    
        socket.on("get_all_word_packs", async () => {
            socket.emit("word_packs", await getAllCodenamesWordPacks());
        });
    
        socket.on("get_word_pack_no_words", async (packId) => {
            let result = packIdZodSchema.safeParse(packId);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            packId = result.data;
            
            socket.emit("word_pack_no_words", await getCodenamesWordPackNoWords(packId));
        });
    
        socket.on("get_words_from_word_pack", async (packId) => {
            let result = packIdZodSchema.safeParse(packId);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            packId = result.data;
            
            socket.emit("words_from_word_pack", await getWordsFromPack(packId));
        });
    
        socket.on("set_new_game_rules", async (newGameRules) => {
            let result = gameRulesZodSchemaNonStrict.safeParse(newGameRules);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            newGameRules = result.data;

            const room = new RoomContext(roomId);
            
            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }

            await safeRoomDataAccess(room, async (room) => {
                let gameRules = await room.getGameRules();
    
                const oldTeamAmount = gameRules.teamAmount;
                if (oldTeamAmount < newGameRules.teamAmount) {
                    if (oldTeamAmount === 2) {
                        if (newGameRules.teamAmount >= 3) {
                            newGameRules.teamOrder.push("blue");
                        }
                        if (newGameRules.teamAmount >= 4) {
                            newGameRules.teamOrder.push("yellow");
                        }
                    } else if (oldTeamAmount === 3) {
                        if (newGameRules.teamAmount >= 4) {
                            newGameRules.teamOrder.push("yellow");
                        }
                    }
                } else if (oldTeamAmount > newGameRules.teamAmount) {
                    if (oldTeamAmount === 4) {
                        if (newGameRules.teamAmount <= 3) {
                            newGameRules.teamOrder = newGameRules.teamOrder.filter((color) => color !== "yellow");
                        }
                        if (newGameRules.teamAmount <= 2) {
                            newGameRules.teamOrder = newGameRules.teamOrder.filter((color) => color !== "blue");
                        }
                    } else if (oldTeamAmount === 3) {
                        if (newGameRules.teamAmount <= 2) {
                            newGameRules.teamOrder = newGameRules.teamOrder.filter((color) => color !== "blue");
                        }
                    }
                }
                
                gameRules = newGameRules;
                switch(gameRules.fieldSize) {
                    case "5x5":
                        gameRules.maxCards = 25;
                        break;
                    case "5x6":
                        gameRules.maxCards = 30;
                        break;
                    case "6x6":
                        gameRules.maxCards = 36;
                        break;
                    case "6x7":
                        gameRules.maxCards = 42;
                        break;
                    case "7x7":
                        gameRules.maxCards = 49;
                        break;
                }

                room.setGameRules(gameRules);
    
                io.to(room.roomId).emit("update_game_rules", gameRules);

                await room.save();
            });

            await room.save();
        });
    
        socket.on("start_new_game", async (randomizeTeamOrder, getNewGameboard) => {
            let result = z.boolean().safeParse(randomizeTeamOrder);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            randomizeTeamOrder = result.data;
            result = z.boolean().safeParse(getNewGameboard);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            getNewGameboard = result.data;
            
            const room = new RoomContext(roomId, true);
            
            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }

            let gameRules = await room.getGameRules();
            let resultGameRules = gameRulesZodSchemaStrict.safeParse(gameRules);
            if (!resultGameRules.success) {
                console.log("Zod error:", result.error);
                socket.emit("error_message", "gameRulesInvalid");
                return;
            }

            await safeRoomDataAccess(room, async (room) => {
                let gameRules = await room.getGameRules();
                let gameProcess = await room.getGameProcess();
    
                if (gameProcess.isGoing) {
                    clearInterval(timerInterval);
                    await processWin(room, "tie");
                } else {
                    const newCardsAmount = totalCards(gameRules);
                    if (newCardsAmount > gameRules.maxCards) {
                        socket.emit("error_message", "cardAmountError");
                        return;
                    } 
    
                    await startNewGame(room, randomizeTeamOrder, getNewGameboard);

                    gameRules = await room.getGameRules();

                    io.to(room.roomId).emit("update_game_rules", gameRules);
    
                    let gameWinStatus = await room.getGameWinStatus();
                    io.to(room.roomId).emit("start_game", gameWinStatus);
                    io.to(room.roomId).emit("setup_new_game");
                    
                    if (timerInterval) {
                        clearInterval(timerInterval);
                    }
                    timerInterval = setInterval(async () => {
                        const stopTimer = await updateGameTimer(room, 0.5);
                        if (stopTimer) {
                            let users = await room.getUsers();
                            let teams = await room.getTeams();
        
                            const selectedSomething = await wordAutoselect(room);
                            const gp = await room.getGameProcess();
                            io.to(room.roomId).emit("update_game_process", gp);
                            io.to(room.roomId).emit("request_new_gameboard");
                            io.to(room.roomId).emit("update_users", teams, users);
                            if (!selectedSomething) {
                                await passTurn(room);
                            }
                        }
                        const gameProcess = await room.getGameProcess();
                        if (!gameProcess.isGoing) {
                            clearInterval(timerInterval);
                        }
                        io.to(room.roomId).emit("update_game_process", gameProcess);
                    }, 500);
                }

                gameProcess = await room.getGameProcess();
    
                io.to(room.roomId).emit("update_game_process", gameProcess);
                io.to(room.roomId).emit("request_new_gameboard");

                await room.save();
            });

            await room.save();
        });
    
        socket.on("get_traitors", async () => {
            const room = new RoomContext(roomId);

            let users = await room.getUsers();
            let traitors = await room.getTraitors();
    
            const objIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            if (objIndex !== -1 && users[objIndex].state.master === true) {
                traitors = traitors.filter((traitor) => traitor.state.teamColor !== users[objIndex].state.teamColor);
            } else if (traitors.some((traitor) => traitor.id === userCodenamesId)) {
                traitors = traitors.filter((traitor) => traitor.id === userCodenamesId);
            } else {
                traitors = [];
            }
            
            socket.emit("update_traitors", traitors);

            await room.save();
        });
    
        socket.on("send_clue", async (clueText, teamColor) => {
            let result = clueTextZodSchema.safeParse(clueText);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            clueText = result.data;
            result = validTeamColorZodSchema.safeParse(teamColor);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            teamColor = result.data;
            
            const room = new RoomContext(roomId);

            if (!checkPermissions(room, userCodenamesId, Permissions.MASTER)) {
                return;
            }
            
            let clueIDCounter = await room.getClueIDCounter();
            let gameRules = await room.getGameRules();
            let gameProcess = await room.getGameProcess();
    
            gameProcess.clues[teamColor].push({
                text: clueText,
                id: clueIDCounter++
            });
            gameProcess.masterTurn = false;
            if (!gameProcess.teamTimeStarted) {
                gameProcess.teamTimeStarted = true;
                gameProcess.timeLeft = gameRules.teamTurnTime;
                if (gameProcess.timeLeft === 0) {
                    gameProcess.infiniteTime = true;
                } else {
                    gameProcess.infiniteTime = false;
                }
            }
            
            room.setClueIDCounter(clueIDCounter);
            room.setGameProcess(gameProcess);
            
            io.to(roomId).emit("update_game_process", gameProcess);

            await room.save();
        });
    
        socket.on("edit_clue", async (newClue) => {
            let result = clueZodSchema.safeParse(newClue);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            newClue = result.data;
            
            const room = new RoomContext(roomId);
            
            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }

            let gameProcess = await room.getGameProcess();
    
            let clueIndex = -1;
            for (let color in gameProcess.clues) {
                clueIndex = gameProcess.clues[color].findIndex((clue) => clue.id === newClue.id);
                if (clueIndex !== -1) {
                    gameProcess.clues[color][clueIndex].text = newClue.text;
                    break;
                }
            }
    
            room.setGameProcess(gameProcess);
    
            io.to(roomId).emit("update_game_process", gameProcess);

            await room.save();
        });
    
        socket.on("get_clues", async () => {
            const room = new RoomContext(roomId);

            let gameProcess = await room.getGameProcess();
    
            socket.emit("update_clues", gameProcess.clues);

            await room.save();
        });
    
        socket.on("select_word", async (selectedWord) => {
            let result = z.string().min(1).safeParse(selectedWord);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            selectedWord = result.data;
            
            const room = new RoomContext(roomId);
            
            let currentWords = await room.getCurrentWords();
            if (!currentWords.some((word) => word.text === selectedWord) && selectedWord !== "endTurn") {
                console.log("Invalid word was selected:", selectedWord);
                return;
            }
            
            let users = await room.getUsers();
    
            const selecterIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            await toggleWord(room, selectedWord, selecterIndex, countdownInterval);
    
            let teams = await room.getTeams();
            let gameRules = await room.getGameRules();
            let gameProcess = await room.getGameProcess();
            currentWords = await room.getCurrentWords();
    
            const wordObjectIndex = currentWords.findIndex((word) => word.text === selectedWord);
            const selecters = wordObjectIndex !== -1 ? currentWords[wordObjectIndex].selectedBy : gameProcess.endTurnSelected;
    
            if (selecters.length === teams[gameProcess.currentTurn].team.length) {
                io.to(roomId).emit("start_countdown", selectedWord);
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                }
                let timer = gameRules.countdownTime;
                let freezed = false;
                countdownInterval = setInterval(async () => {
                    timer -= 0.01;
    
                    if (timer <= 0 && !freezed) {
                        freezed = true;
                        timer = 0;
                        io.to(roomId).emit("stop_countdown");
                        await revealWord(room, selectedWord);
                        gameProcess = await room.getGameProcess();
                        io.to(roomId).emit("request_new_gameboard");
                        io.to(roomId).emit("update_game_process", gameProcess);
                        clearInterval(countdownInterval);
                    }
    
                    io.to(roomId).emit("update_countdown", 1 - timer / gameRules.countdownTime);
                }, 10);
            } else {
                clearInterval(countdownInterval);
                io.to(roomId).emit("stop_countdown");
            }
    
            users = await room.getUsers();
            gameProcess = await room.getGameProcess();
    
            io.to(roomId).emit("request_new_gameboard");
            io.to(roomId).emit("update_game_process", gameProcess);
            io.to(roomId).emit("update_users", teams, users);
            socket.emit("update_client", teams, users, users[selecterIndex], gameRules, gameProcess); // Possibly need old one!!!

            await room.save();
        });
    
        socket.on("proceed_click", (clickedWordText) => {
            let result = z.string().min(1).safeParse(clickedWordText);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            clickedWordText = result.data;
            
            io.to(roomId).emit("click_word", clickedWordText, userCodenamesId);
        });
    
        socket.on("get_game_process", async () => {
            const room = new RoomContext(roomId);

            let gameProcess = await room.getGameProcess();
    
            socket.emit("update_game_process", gameProcess);

            await room.save();
        });
    
        socket.on("pass_turn", async () => {
            const room = new RoomContext(roomId);

            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }
            
            let users = await room.getUsers();
            let teams = await room.getTeams();
    
            await clearAllSelections(room);
            await passTurn(room);

            let gameProcess = await room.getGameProcess();
    
            io.to(roomId).emit("update_game_process", gameProcess);
            io.to(roomId).emit("request_new_gameboard");
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });
    
        socket.on("remove_all_players", async (withMasters) => {
            let result = z.boolean().safeParse(withMasters);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            withMasters = result.data;
            
            const room = new RoomContext(roomId);

            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }
    
            await removeAllPlayers(room, withMasters);
    
            let users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });
    
        socket.on("remove_player", async (playerId) => {
            let result = playerIdZomSchema.safeParse(playerId);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            playerId = result.data;
            
            const room = new RoomContext(roomId);
            
            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }
    
            await removePlayer(room, playerId);
    
            let users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });
    
        socket.on("randomize_players", async (withMasters) => {
            let result = z.boolean().safeParse(withMasters);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            withMasters = result.data;
            
            const room = new RoomContext(roomId);
            
            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }
    
            await randomizePlayers(room, withMasters);
    
            let users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });
        
        socket.on("transfer_host", async (playerId) => {
            let result = playerIdZomSchema.safeParse(playerId);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            playerId = result.data;
            
            const room = new RoomContext(roomId);
            
            if (!checkPermissions(room, userCodenamesId, Permissions.HOST)) {
                return;
            }
    
            await transferHost(room, userCodenamesId, playerId);
    
            let users = await room.getUsers();
            let teams = await room.getTeams();
    
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });

        socket.on("send_new_chat_message", async (messageText) => {
            let result = chatMessageZodSchema.safeParse(messageText);
            if (!result.success) {
                console.log("Zod error:", result.error);
                return;
            }
            messageText = result.data;
            
            const room = new RoomContext(roomId);

            let users = await room.getUsers();

            const objIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            let sender = users[objIndex];

            result = await addCodenamesChatMessageToRoomData(roomId, sender.name, userCodenamesId, messageText);

            await room.getChatMessages();

            const message = {
                senderName: sender.name,
                senderID: userCodenamesId,
                messageText: messageText
            };

            io.to(roomId).emit("add_chat_message", message);

            await room.save();
        });
    
        socket.on('disconnect', async () => {
            const room = new RoomContext(roomId);

            if (!settedUp) {
                console.log("Some shit is going on... user was not setted up");
                return;
            }
            if (!(await validateUser(room, userCodenamesId))) {
                console.log("Some shit is going on... user was not validated");
                return;
            }

            let users = await room.getUsers();
    
            console.log('User disconnected:', socket.handshake.address);

            const objIndex = users.findIndex((obj) => obj.id === userCodenamesId);
            console.log(objIndex);
            let newUser = users[objIndex];
            newUser.online = false;
            await updateUser(room, newUser);

            let teams = await room.getTeams();
            users = await room.getUsers();
            if (users.every((user) => !user.online)) {
                console.log("Room is AFK now!");
            }
            io.to(roomId).emit("update_users", teams, users);

            await room.save();
        });
    });
}

module.exports = {
    setupCodenames
}